pub struct Parser;
# [allow (dead_code , non_camel_case_types)] # [derive (Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum Rule { EOI , WHITESPACE , COMMENT , Hexadecimal , Binary , Octal , Decimal , Integer , Identifier , IndexRegister , PacketOffset , IndirectPacketOffset , MemoryAddress , Immediate , PacketOffsetMSH , Jump , JumpImmediate , JumpIndexRegister , JumpIfImmediate , JumpIfIndexRegister , AccumulatorRegister , Length , Extension , LD , LDI , LDH , LDB , LDX , LDXI , LDXB , ST , STX , JMP , JEQ , JNEQ , JLT , JLE , JGT , JGE , JSET , ADD , SUB , MUL , DIV , MOD , NEG , AND , OR , XOR , LSH , RSH , TAX , TXA , COP , COPX , RET , Label , Instruction , Program } # [allow (clippy :: all)] impl :: pest :: Parser < Rule > for Parser { fn parse < 'i > (rule : Rule , input : & 'i str) -> :: std :: result :: Result < :: pest :: iterators :: Pairs < 'i , Rule > , :: pest :: error :: Error < Rule > > { mod rules { pub mod hidden { use super :: super :: Rule ; # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn skip (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { if state . atomicity () == :: pest :: Atomicity :: NonAtomic { state . sequence (| state | { state . repeat (| state | super :: visible :: WHITESPACE (state)) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: visible :: COMMENT (state) . and_then (| state | { state . repeat (| state | super :: visible :: WHITESPACE (state)) }) }) }) }) }) } else { Ok (state) } } } pub mod visible { use super :: super :: Rule ; # [inline] # [allow (non_snake_case , unused_variables)] pub fn WHITESPACE (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: Atomic , | state | { self :: WHITE_SPACE (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn COMMENT (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("/*") . and_then (| state | { state . repeat (| state | { state . sequence (| state | { state . lookahead (false , | state | { state . match_string ("*/") }) . and_then (| state | { self :: ANY (state) }) }) }) }) . and_then (| state | { state . match_string ("*/") }) }) . or_else (| state | { state . sequence (| state | { state . match_string (";") . and_then (| state | { state . repeat (| state | { state . sequence (| state | { state . lookahead (false , | state | { self :: NEWLINE (state) }) . and_then (| state | { self :: ANY (state) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Hexadecimal (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: Hexadecimal , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("0x") . and_then (| state | { self :: ASCII_HEX_DIGIT (state) }) . and_then (| state | { state . repeat (| state | { self :: ASCII_HEX_DIGIT (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Binary (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: Binary , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("0b") . and_then (| state | { state . match_range ('0' .. '1') }) . and_then (| state | { state . repeat (| state | { state . match_range ('0' .. '1') }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Octal (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: Octal , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("0") . and_then (| state | { self :: ASCII_OCT_DIGIT (state) }) . and_then (| state | { state . repeat (| state | { self :: ASCII_OCT_DIGIT (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Decimal (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: Decimal , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string ("0") . or_else (| state | { state . sequence (| state | { state . optional (| state | { state . match_string ("-") . or_else (| state | { state . match_string ("+") }) }) . and_then (| state | { self :: ASCII_NONZERO_DIGIT (state) }) . and_then (| state | { state . repeat (| state | { self :: ASCII_DIGIT (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Integer (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { self :: Hexadecimal (state) . or_else (| state | { self :: Binary (state) }) . or_else (| state | { self :: Octal (state) }) . or_else (| state | { self :: Decimal (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Identifier (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: Identifier , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { self :: ASCII_ALPHA (state) . and_then (| state | { state . repeat (| state | { self :: ASCII_ALPHANUMERIC (state) . or_else (| state | { state . match_string ("_") }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn IndexRegister (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: IndexRegister , | state | { state . match_string ("x") . or_else (| state | { state . match_string ("%x") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn PacketOffset (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: PacketOffset , | state | { state . sequence (| state | { state . match_string ("[") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Integer (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("]") }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn IndirectPacketOffset (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: IndirectPacketOffset , | state | { state . sequence (| state | { state . match_string ("[") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("x") . or_else (| state | { state . match_string ("%x") }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("+") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Integer (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("]") }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn MemoryAddress (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: MemoryAddress , | state | { state . sequence (| state | { state . match_string ("M") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("[") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Integer (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("]") }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Immediate (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: Immediate , | state | { state . sequence (| state | { state . optional (| state | { state . match_string ("#") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Integer (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn PacketOffsetMSH (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: PacketOffsetMSH , | state | { state . sequence (| state | { state . match_string ("4") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("*") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("(") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("[") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Integer (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("]") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("&") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("0xf") . or_else (| state | { state . match_string ("0xF") }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (")") }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Jump (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: Jump , | state | { self :: Identifier (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JumpImmediate (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: JumpImmediate , | state | { state . sequence (| state | { state . match_string ("#") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Integer (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Identifier (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Identifier (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JumpIndexRegister (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: JumpIndexRegister , | state | { state . sequence (| state | { state . match_string ("x") . or_else (| state | { state . match_string ("%x") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Identifier (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Identifier (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JumpIfImmediate (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: JumpIfImmediate , | state | { state . sequence (| state | { state . match_string ("#") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Integer (state) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Identifier (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JumpIfIndexRegister (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: JumpIfIndexRegister , | state | { state . sequence (| state | { state . match_string ("x") . or_else (| state | { state . match_string ("%x") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (",") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Identifier (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn AccumulatorRegister (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: AccumulatorRegister , | state | { state . match_string ("a") . or_else (| state | { state . match_string ("%a") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Length (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: Length , | state | { state . sequence (| state | { state . optional (| state | { state . match_string ("#") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string ("len") . or_else (| state | { state . match_string ("pktlen") }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Extension (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . atomic (:: pest :: Atomicity :: NonAtomic , | state | { state . rule (Rule :: Extension , | state | { state . sequence (| state | { state . optional (| state | { state . match_string ("#") }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: Identifier (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn LD (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: LD , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("ld") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: PacketOffset (state) . or_else (| state | { self :: IndirectPacketOffset (state) }) . or_else (| state | { self :: MemoryAddress (state) }) . or_else (| state | { self :: Immediate (state) }) . or_else (| state | { self :: Length (state) }) . or_else (| state | { self :: Extension (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn LDI (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: LDI , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("ldi") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: Immediate (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn LDH (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: LDH , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("ldh") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: PacketOffset (state) . or_else (| state | { self :: IndirectPacketOffset (state) }) . or_else (| state | { self :: Extension (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn LDB (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: LDB , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("ldb") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: PacketOffset (state) . or_else (| state | { self :: IndirectPacketOffset (state) }) . or_else (| state | { self :: Extension (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn LDX (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: LDX , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("ldx") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: MemoryAddress (state) . or_else (| state | { self :: PacketOffsetMSH (state) }) . or_else (| state | { self :: Immediate (state) }) . or_else (| state | { self :: Length (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn LDXI (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: LDXI , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("ldxi") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: Immediate (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn LDXB (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: LDXB , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("ldxb") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: PacketOffsetMSH (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn ST (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: ST , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("st") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: MemoryAddress (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn STX (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: STX , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("stx") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: MemoryAddress (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JMP (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: JMP , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("jmp") . or_else (| state | { state . match_string ("ja") }) . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: Jump (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JEQ (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: JEQ , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("jeq") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: JumpIndexRegister (state) . or_else (| state | { self :: JumpIfIndexRegister (state) }) . or_else (| state | { self :: JumpImmediate (state) }) . or_else (| state | { self :: JumpIfImmediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JNEQ (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: JNEQ , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("jneq") . or_else (| state | { state . match_string ("jne") }) . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: JumpIfIndexRegister (state) . or_else (| state | { self :: JumpIfImmediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JLT (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: JLT , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("jlt") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: JumpIfIndexRegister (state) . or_else (| state | { self :: JumpIfImmediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JLE (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: JLE , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("jle") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: JumpIfIndexRegister (state) . or_else (| state | { self :: JumpIfImmediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JGT (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: JGT , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("jgt") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: JumpIndexRegister (state) . or_else (| state | { self :: JumpIfIndexRegister (state) }) . or_else (| state | { self :: JumpImmediate (state) }) . or_else (| state | { self :: JumpIfImmediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JGE (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: JGE , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("jge") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: JumpIndexRegister (state) . or_else (| state | { self :: JumpIfIndexRegister (state) }) . or_else (| state | { self :: JumpImmediate (state) }) . or_else (| state | { self :: JumpIfImmediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn JSET (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: JSET , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("jset") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: JumpIndexRegister (state) . or_else (| state | { self :: JumpIfIndexRegister (state) }) . or_else (| state | { self :: JumpImmediate (state) }) . or_else (| state | { self :: JumpIfImmediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn ADD (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: ADD , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("add") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: IndexRegister (state) . or_else (| state | { self :: Immediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn SUB (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: SUB , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("sub") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: IndexRegister (state) . or_else (| state | { self :: Immediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn MUL (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: MUL , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("mul") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: IndexRegister (state) . or_else (| state | { self :: Immediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn DIV (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: DIV , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("div") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: IndexRegister (state) . or_else (| state | { self :: Immediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn MOD (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: MOD , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("mod") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: IndexRegister (state) . or_else (| state | { self :: Immediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn NEG (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: NEG , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string ("neg") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn AND (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: AND , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("and") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: IndexRegister (state) . or_else (| state | { self :: Immediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn OR (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: OR , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("or") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: IndexRegister (state) . or_else (| state | { self :: Immediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn XOR (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: XOR , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("xor") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: IndexRegister (state) . or_else (| state | { self :: Immediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn LSH (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: LSH , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("lsh") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: IndexRegister (state) . or_else (| state | { self :: Immediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn RSH (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: RSH , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("rsh") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: IndexRegister (state) . or_else (| state | { self :: Immediate (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn TAX (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: TAX , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string ("tax") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn TXA (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: TXA , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string ("txa") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn COP (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: COP , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("cop") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: Immediate (state) . or_else (| state | { self :: Extension (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn COPX (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: COPX , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string ("copx") }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn RET (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: RET , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string ("ret") . and_then (| state | { state . sequence (| state | { self :: WHITE_SPACE (state) . and_then (| state | { state . repeat (| state | { self :: WHITE_SPACE (state) }) }) }) }) . and_then (| state | { self :: Immediate (state) . or_else (| state | { self :: IndexRegister (state) }) . or_else (| state | { self :: AccumulatorRegister (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Label (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: Label , | state | { state . sequence (| state | { self :: Identifier (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (":") }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Instruction (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { self :: LD (state) . or_else (| state | { self :: LDI (state) }) . or_else (| state | { self :: LDH (state) }) . or_else (| state | { self :: LDB (state) }) . or_else (| state | { self :: LDX (state) }) . or_else (| state | { self :: LDXI (state) }) . or_else (| state | { self :: LDXB (state) }) . or_else (| state | { self :: ST (state) }) . or_else (| state | { self :: STX (state) }) . or_else (| state | { self :: JMP (state) }) . or_else (| state | { self :: JEQ (state) }) . or_else (| state | { self :: JNEQ (state) }) . or_else (| state | { self :: JLT (state) }) . or_else (| state | { self :: JLE (state) }) . or_else (| state | { self :: JGT (state) }) . or_else (| state | { self :: JGE (state) }) . or_else (| state | { self :: JSET (state) }) . or_else (| state | { self :: ADD (state) }) . or_else (| state | { self :: SUB (state) }) . or_else (| state | { self :: MUL (state) }) . or_else (| state | { self :: DIV (state) }) . or_else (| state | { self :: MOD (state) }) . or_else (| state | { self :: NEG (state) }) . or_else (| state | { self :: AND (state) }) . or_else (| state | { self :: OR (state) }) . or_else (| state | { self :: XOR (state) }) . or_else (| state | { self :: LSH (state) }) . or_else (| state | { self :: RSH (state) }) . or_else (| state | { self :: TAX (state) }) . or_else (| state | { self :: TXA (state) }) . or_else (| state | { self :: COP (state) }) . or_else (| state | { self :: COPX (state) }) . or_else (| state | { self :: RET (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] pub fn Program (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . sequence (| state | { self :: SOI (state) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { self :: Label (state) . or_else (| state | { self :: Instruction (state) }) . or_else (| state | { self :: NEWLINE (state) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { self :: Label (state) . or_else (| state | { self :: Instruction (state) }) . or_else (| state | { self :: NEWLINE (state) }) }) }) }) }) }) }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { self :: EOI (state) }) }) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn ANY (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . skip (1) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn EOI (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . rule (Rule :: EOI , | state | state . end_of_input ()) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn SOI (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . start_of_input () } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn ASCII_DIGIT (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . match_range ('0' ..'9') } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn ASCII_NONZERO_DIGIT (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . match_range ('1' ..'9') } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn ASCII_OCT_DIGIT (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . match_range ('0' ..'7') } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn ASCII_HEX_DIGIT (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . match_range ('0' ..'9') . or_else (| state | state . match_range ('a' ..'f')) . or_else (| state | state . match_range ('A' ..'F')) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn ASCII_ALPHA (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . match_range ('a' ..'z') . or_else (| state | state . match_range ('A' ..'Z')) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn ASCII_ALPHANUMERIC (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . match_range ('a' ..'z') . or_else (| state | state . match_range ('A' ..'Z')) . or_else (| state | state . match_range ('0' ..'9')) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] pub fn NEWLINE (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . match_string ("\n") . or_else (| state | state . match_string ("\r\n")) . or_else (| state | state . match_string ("\r")) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] fn WHITE_SPACE (state : Box < :: pest :: ParserState < Rule >>) -> :: pest :: ParseResult < Box < :: pest :: ParserState < Rule >> > { state . match_char_by (:: pest :: unicode :: WHITE_SPACE) } } pub use self :: visible :: * ; } :: pest :: state (input , | state | { match rule { Rule :: WHITESPACE => rules :: WHITESPACE (state) , Rule :: COMMENT => rules :: COMMENT (state) , Rule :: Hexadecimal => rules :: Hexadecimal (state) , Rule :: Binary => rules :: Binary (state) , Rule :: Octal => rules :: Octal (state) , Rule :: Decimal => rules :: Decimal (state) , Rule :: Integer => rules :: Integer (state) , Rule :: Identifier => rules :: Identifier (state) , Rule :: IndexRegister => rules :: IndexRegister (state) , Rule :: PacketOffset => rules :: PacketOffset (state) , Rule :: IndirectPacketOffset => rules :: IndirectPacketOffset (state) , Rule :: MemoryAddress => rules :: MemoryAddress (state) , Rule :: Immediate => rules :: Immediate (state) , Rule :: PacketOffsetMSH => rules :: PacketOffsetMSH (state) , Rule :: Jump => rules :: Jump (state) , Rule :: JumpImmediate => rules :: JumpImmediate (state) , Rule :: JumpIndexRegister => rules :: JumpIndexRegister (state) , Rule :: JumpIfImmediate => rules :: JumpIfImmediate (state) , Rule :: JumpIfIndexRegister => rules :: JumpIfIndexRegister (state) , Rule :: AccumulatorRegister => rules :: AccumulatorRegister (state) , Rule :: Length => rules :: Length (state) , Rule :: Extension => rules :: Extension (state) , Rule :: LD => rules :: LD (state) , Rule :: LDI => rules :: LDI (state) , Rule :: LDH => rules :: LDH (state) , Rule :: LDB => rules :: LDB (state) , Rule :: LDX => rules :: LDX (state) , Rule :: LDXI => rules :: LDXI (state) , Rule :: LDXB => rules :: LDXB (state) , Rule :: ST => rules :: ST (state) , Rule :: STX => rules :: STX (state) , Rule :: JMP => rules :: JMP (state) , Rule :: JEQ => rules :: JEQ (state) , Rule :: JNEQ => rules :: JNEQ (state) , Rule :: JLT => rules :: JLT (state) , Rule :: JLE => rules :: JLE (state) , Rule :: JGT => rules :: JGT (state) , Rule :: JGE => rules :: JGE (state) , Rule :: JSET => rules :: JSET (state) , Rule :: ADD => rules :: ADD (state) , Rule :: SUB => rules :: SUB (state) , Rule :: MUL => rules :: MUL (state) , Rule :: DIV => rules :: DIV (state) , Rule :: MOD => rules :: MOD (state) , Rule :: NEG => rules :: NEG (state) , Rule :: AND => rules :: AND (state) , Rule :: OR => rules :: OR (state) , Rule :: XOR => rules :: XOR (state) , Rule :: LSH => rules :: LSH (state) , Rule :: RSH => rules :: RSH (state) , Rule :: TAX => rules :: TAX (state) , Rule :: TXA => rules :: TXA (state) , Rule :: COP => rules :: COP (state) , Rule :: COPX => rules :: COPX (state) , Rule :: RET => rules :: RET (state) , Rule :: Label => rules :: Label (state) , Rule :: Instruction => rules :: Instruction (state) , Rule :: Program => rules :: Program (state) , Rule :: EOI => rules :: EOI (state) } }) } }
